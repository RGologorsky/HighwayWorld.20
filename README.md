# ONGOING WORK

## Details coming soon.

### File Summary

#### Abstract Car class - contains variables and functions common to all cars. 
Stores its highway as an instance variable. The AgentCar, MergingCar, OtherCar classes inherent common features and functionality from AbstractCar but customize the move function in order to implement specific behaviors. The AbstractCarMixin class contains helper functions specific to the Car class, such as init functions, is\_collision, and dist\_to\_lane\_boundary.\newline

#### Highway class - creates the highway. 
Stores a list a cars on the highway. Responsible for majority of drawing functions, encapsulated in the HighwayMixin class. \newline

#### Simulator class - interfaces between a car's state and action inputs. 
By default, action inputs are continuous steering angle and acceleration/brake input. However, can be easily customized and discretized by changing the functions called to process the raw input. Note:  Steering angle is measured in radians from the y-axis (clockwise from the y-axis is positive).\newline

#### Playback class - contains key recording/playback functionality: writing to file, reading stored data from file, and visualizing the recorded demonstration. 
By default, the data - a list of the general highway parameters and the time series of all the cars on the highway - is pickled. The content and storage mechanism is easily modifiable by changing the write\_recorded\_data and get\_recorded\_data functions. The data is generated in the game\_events file by the “RECORD\_HIGHWAY\_EVENT,” which fires with the frequency set in the constants file. \newline

#### Dynamics.py - contains the physical dynamics model, by default Kinematic Bicycle Dynamics. 
Easily customizable by changing the next\_step function in the dynamics file. Other models (such as the simpler point-mass or the more complex ones incorporating friction) can be easily substituted by changing the next\_step function in the dynamics file.  Note: the Kinematic Bicycle Dynamics Mode simulates real car dynamics surprisingly well as long as the lateral acceleration is not too high \cite{bicycle}. \newline

#### Constants - contains global constants. Collected into a single file so that they can be easily found and modified. 
These constants include the Pygame window's height and width dimensions, event timer frequencies (e.g. how often should the draw all function be called or the highway recorded), and sundry others constants (e.g. common colors).\newline

#### Helpers - contains general helper functions, which can be classified into 3 main categories: those that detect game events, deal with geometry, or are just generally useful. Note about geometry: the coordinate system used throughout is that of Pygame, i.e.  the y-axis is orientated to be increasing from top to bottom.\newline

#### Scenarios - defines some common start scenarios, 
where I illustrate how to predetermined the number of highway lanes, the types of cars, and their speeds, headings, and positions. Over time, this file can be expanded into a library of different deterministic and randomly generated testing scenarios.\newline

#### Game Events - 
handles game events such as Move\_Car\_Event and Record\_Highway\_Event timer events (frequency defined in the constants file), action inputs (passes them to the Simulator class), and other user-driven events such as pause, quit, and restart (defined in the helpers file).\newline

#### Main file  - 
contains two functions, play\_game, and play\_back. Play\_game starts the game with the given input start scenario, and calling play\_back with a specific file name plays back the demonstration that file captured. In both functions, a while loop iterates through the events generated by the game/playback until the game/playback is done. For readability, the events are identified and handled in the game events file.\newline

### Key Mechanism
A highway object is required for a car's initialization (other parameters are optional). At initialization, the car adds itself to its highway instance's car\_list field. Thus, the highway has a list of all car objects on it. As a result, every car has, through its highway instance, access to all the other car objects on the road. Since Python implements “Call by Reference,” each car's highway instance always reflects the current highway object and the highway object's car list reflects the current car objects. 

#### Unrestricted information sharing has a number of benefits. First, it allows all conceivable state features to be implemented because there is complete access to the highway and all the other cars' states. In addition, it simplifies the implementation of car behaviors that depend on neighboring car state and common functions such as checking for collisions (simply scan the highway's car object list), projecting the highway state into the future, and playing back demonstrations. Since most toy scenarios include $<20$ cars, iterating through the highway's car list is an efficient and simplifying design decision.

#### Visualization
In order to allow for unlimited human demonstration and the illusion of an infinite length track, all the objects on the highway move down rather than the agent car moving up. Hence the agent car's objective position never changes, though it advances relative to the other cars and reference points on the road. To aid in visualization, I added a simple “Tree” object by the highway to serve as a reference point for human drivers. In dashed lanes, I introduce a time parity parameter, "odd\_timestep," in order to alternate between revealing "new" dashed lane separators and translating the "old" ones down.


### Future Directions



- An expanded car behavior library so that researchers could “plug and play” desired car behaviors into their research (e.g. rule-based/aggressive/timid driver models, cars pre-programmed to merge in a certain way).
- An Obstacle class to incorporate common car-obstacle interactions and model lane merge and highway exit behavior.
- A Graphical User Interface to ease scenario creation.
- Introduction of more precise polygonal (instead of rectangular) car bounding boxes into the car geometry.
- A library for different Physical dynamics models.
- An extended environment scope to intersections and other situations of research significance.

In the future, I hope that researchers will recognize the utility of a common starting point, and develop this highway environment into a high-level springboard for other research investigations.




### Appendix

#### Car Classes Derived from **AbstractCar**


- The **OtherCar** class implements behavior of a general car on the road, which I programmed to to be: staying in its lane, adjusting its speed to keep its preferred distance to the car ahead, returning to its preferred speed when possible, and never crashing into the car  in front.
- The **MergingCar** class roughly implements a car programmed to merge into the left lane; the merging car uses deterministic heuristics to guide its attempted lane merge.
- The **AgentCar** class implements behavior specific to the human-controlled vehicle - its behavior reflects that of the user controlling it. It is the only vehicle I allow to crash into other cars. 


The AbstractCar move method is itself general, and has optional parameters that govern whether a car is allowed to collide with another car, whether it can go off-road, and whether its keeps a set distance from the car in front of it. Thus, the Abstract Car class provides a flexible starting point from which cars with different behaviors can be derived. 

As the name suggests, the Abstract Car class is an abstract class meant to define common car behavior while leaving the specifics to its derived classes. However, the AbstractCar class has an init method meant to be called by the derived classes in order to initialize some common variables. The only required argument to this init function is the car's highway object, though optional arguments include a simulator object to interface with action inputs, and the desired initial x,y coordinates of the car's center, and its lane, lane position, speed, and role. 

#### Explication of the Differences between Similar Car Instance Variables

**x,y vs. lane, lane position.**: The x and y position are closely related to, though not exactly equivalent to, the lane and lane position. The lane is a discrete number corresponding to the lane number (0-indexed), while the x-value is a float that stores the precise x-coordinate of the pixel representing the car center. The lane position is a float that stores the precise y-coordinate indicating how far the car center is from the beginning of the highway track (i.e. increases from bottom to top);  in Pygame, however, the y-coordinate of the pixel position increases from the top down. Thus, the pixel y-value = highway length - the lane position. In the AbstractClass Mixin (which contains helper functions specific to cars), there are functions for converting x and y positions to lane and lane positions, and vice versa (when converting a lane number to a x value, the x value is calculated as the center point of the lane).  

**Role vs ID.**: At each initialization, each car is given a unique "ID" number generated by a counter variable. This ID provides an efficient way to perform equality tests between car objects. In contrast, the role variable (a modifiable string parameter set at initialization) is used to identify special vehicles (such as the agent car) in functions.

#### Default Initialization of Optional Car Instance Variables
When the optional arguments are not provided, the vehicle settings (x, y, lane, lane position, and speed) are instantiated with functions such as init\_place, which sets the lane and lane position, init\_pixel\_pos, which sets the x and y position based on the previously set lane and lane position, and init\_speed, which initiates the speed. These init functions grant flexibility over the parameters' default initialization. For example, I implemented the init\_speed function to initialize a car's speed via a Gaussian distribution whose mean depends on the car's lane in order to incorporate the highway driving convention that the left lane tends to have faster vehicles.\newline

There are some common variables that I initialize to have default values that could be analogously be customized or passed in as initialization parameters.  For example, I initialize the car to have a vertical heading - $pi/2$ radians, i.e. 90 degrees counterclockwise from the x-axis, and set l\_f and l\_r (distance from the center of mass to the front and rear axles, respectively) with default value.

#### Highway Parameters.
The highway length, lane width, and number of lanes can be configured at initialization, as can the color of the lane separator markings, road border, and road color. The drawing functions are encapsulated by the Highway Mixin class, and are highly modular and customizable. The drawing functions in the Highway Mixin class are also used by the Playback class to play back a prior recorded human demonstration. 


#### Selected Functions Highlighting Car-Highway Information Sharing

**Get\_closest\_cars** is a function in the highway class that, when given a lane and lane position, returns a list with information about the car state ahead and behind in the given and neighboring lanes. It relies on **get\_closest\_car**, which finds the closest car object on the highway in the specific direction to find the desired car information. I use this highway function in my car class to get the state features of the gap size and speed of the cars ahead and behind the agent car in its lane and in the neighboring lanes.

**Crash\_in\_n\_steps** is a highway function that uses the dynamics model to simulate whether continuing the current trajectories would result in a car crash within the next n steps. This function is used by my MergingCar to inform its decision on how far to turn the steering wheel and how much to accelerate during a lane merge. A further refinement would incorporate reactions rather than simply projecting all current car inputs into the future.

#### Visualization
The HighwayMixin class handles most of the drawing functionality: it draws the road, then the dashed lines, then the cars in its car list and the reference points by calling their draw method on them. By default, the Playback class uses the HighwayMixin draw functions to replay prior demonstrations.
